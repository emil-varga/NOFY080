\newpage
\section{Digitální zpracování signálu}
\subsection{Digitální reprezentace spojitého signálu}
Předpokládejme signál $y(t)$ (např. napětí), který se spojitě mění v čase. Pro uložení a zpracování tohoto signálu na počítači ho měříme v sadě časových okamžiků $t_i$, což nám dává hodnoty signálu $y_i$. Výsledkem je diskrétní reprezentace signálu jako série párů $(t_i, y_i)$. Signál je vzorkován rovnoměrně, pokud $t_i = i\Delta t$, kde $\Delta t$ je \textbf{vzorkovací (\emph{sampling}) perioda} a $f_s = 1/\Delta t$ je \textbf{vzorkovací (\textbf{sampling}) frekvence}.

Jakákoli informace o původním signálu $y(t)$, která se mění v čase rychleji než $\Delta t$, je ztracena. Pokud však $y(t)$ osciluje na frekvenci $f$, nestačí mít $f_s \geq f$. Frekvence signálu $f > f_s/2$ se objeví posunuté na $f - f_s/2$, viz výstup Lst.~\ref{ls:label}. Vzorkovaný signál obsahuje fiktivní frekvence, které v původním signálu nejsou přítomny.

Toto zkreslení se nazývá \textbf{aliasing} a \emph{Nyquistův teorém} říká, že aby se předešlo aliasingu, nejvyšší frekvence obsažená v signálu $f$ nesmí být vyšší než polovina vzorkovací frekvence $f_s/2$, která se nazývá \textbf{Nyquistova frekvence}
\begin{equation}
    \label{eq:nqyust}
    f_N = f_s/2.
\end{equation}

\lstinputlisting[caption=Efekt vzorkovací frekvence, label=ls:label]{../example_code/sampling.py}
\begin{center}
    \includegraphics[width=0.75\linewidth]{sampling.pdf}
\end{center}

\subsection{Spektrální analýza}
Jakýkoli periodický signál $y(t)$ (který může být komplexní) s periodou $T$, tj. $y(t + T) = y(t)$, může být reprezentován jako součet sinových a kosinových členů oscilujících na úhlových frekvencích $2\pi n/T$, kde $n$ je celé číslo,
\begin{equation}
    y(t) = \frac{1}{T} \sum_{k=0}^{\infty} \left[ A'_k\sin\left(\frac{2\pi k}{T}t\right) + B'_k\cos\left(\frac{2\pi k}{T}t\right)\right],
\end{equation}
což se nazývá \textbf{Fourierova řada}. Ekvivalentně lze Fourierovu řadu vyjádřit pomocí komplexních exponenciál
\begin{equation}
    y(t) = \frac{1}{T} \sum_{k=-\infty}^\infty A_k e^{2\pi ikt/T},
\end{equation}
kde pro reálný signál $y$ jsou kladné a záporné členy komplexně sdružené, $A_k = A_{-k}^*$ (faktor $1/T$ a znaménko uvnitř exponenciální funkce jsou dány konvencí).

Fourierovy koeficienty $A_k$ lze vypočítat jako
\begin{equation}
    A_k = \int_0^T y(t) e^{-2\pi ikt/T} \mathrm{d}t
\end{equation}

Například, zvažme přímo vypočtenou Fourierovu řadu v Lst.~\ref{lst:fourier-square-pulse}
\lstinputlisting[label=lst:fourier-square-pulse, caption=Fourierova řada obdélníkového pulzu.]{../example_code/fourier_series_square_wave.py}
\begin{center}
    \includegraphics[width=0.5\linewidth]{fourier_series_square_pulse.pdf}
\end{center}

Tyto definice lze rozšířit na aperiodické signály (které si lze představit jako signály s nekonečně dlouhou periodou), což vede k \textbf{Fourierově transformaci}
\begin{equation}
    \tilde y(\omega) = \int_{-\infty}^\infty y(t)e^{-i\omega t} \mathrm{d}t,
\end{equation}
a \textbf{inverzní Fourierově transformaci}
\begin{equation}
    y(t) = \frac{1}{2\pi}\int_{-\infty}^\infty \tilde y (\omega)e^{i\omega t}\mathrm{d}\omega
\end{equation}

Absolutní hodnota Fourierových koeficientů $|A|$ je amplituda oscilace signálu na dané frekvenci a jejich komplexní fáze je fázové posunutí sinových a kosinových členů. Pro Fourierovu transformaci, jelikož se frekvence nyní mění spojitě, má $|\tilde y|$ význam \emph{hustoty} (nazývané spektrální hustota). V analogii s elektrickým výkonem $P = V^2/R$ potřebným k vytvoření napětí $V$ na rezistoru $R$, se $|\tilde y|^2$ nazývá \emph{výkonová spektrální hustota}, tj. $\int_{\omega_0}^{\omega_1} |\tilde y (\omega)|^2\mathrm{d}\omega$ je výkon signálu ve frekvenčním pásmu $(\omega_0, \omega_1)$.

Pro digitální signály mluvíme o \emph{diskrétních} Fourierových transformacích. Pro rovnoměrně vzorkované signály, $t_n = n\Delta t$, jsou tyto v SciPy definovány jako (v podmodulu \ls{scipy.fft})
\begin{equation}
    \tilde y[k] = \sum_{n=0}^{N-1}y[n]e^{-2\pi i kn/N},
\end{equation}
kde $y[n]$ je hodnota signálu $y$ měřená v čase $t_n = n\Delta t$ a $N$ je celkový počet vzorků. Bezrozměrné celočíselné frekvence $k$ běží od 0 do $N-1$ -- to znamená, že Fourierova transformace má stejnou délku jako původní signál.

Inverzní diskrétní Fourierova transformace je definována podobně,
\begin{equation}
    y[n] = \frac{1}{N}\sum_{k=0}^{N-1}\tilde y[k]e^{+2\pi i kn/N}.
\end{equation}

Celočíselné frekvenční indexy $k$ reprezentují frekvence $f'_k = k/N$ pro $k=0\dots N/2$ a $f'_k = -k/N$ pro $k=N/2\dots N-1$. Pro získání skutečných frekvencí stačí škálovat $f'_k$ skutečnou vzorkovací frekvencí $1/\Delta t$. Všimněte si, že definice diskrétní Fourierovy transformace a její inverze nezávisí na vzorkovací frekvenci, pouze na tom, že signál je vzorkován rovnoměrně.

Fourierovy transformace jsou implementovány v NumPy a SciPy pomocí algoritmu \textbf{Rychlá Fourierova transformace -- FFT}\footnote{FFT je jedním z nejdůležitějších algoritmů, na kterých závisí celý digitální svět -- např. kódování zvuku a videa a bezdrátová komunikace na něm silně spoléhají.} v podmodulu \ls{scipy.fft}. Fourierova transformace se počítá pomocí \ls{scipy.fft.fft()} a skutečné frekvence lze vypočítat pomocí pomocné funkce \ls{scipy.fft.fftfreq()}. Obě funkce \ls{fft} a \ls{fftfreq} vracejí kladné i záporné frekvence. Pro reálné signály neposkytují záporné frekvence žádné další informace, proto můžeme použít \ls{scipy.fft.rfft()} a \ls{rfftfreq()}, které vracejí pouze kladné frekvence (tj. výsledek má poloviční délku původního signálu). Pokud nás zajímá pouze výkonová spektrální hustota, existuje \ls{scipy.signal.periodogram()}, která také počítá frekvence. Ve výchozím nastavení pro reálné signály vrací \ls{periodogram} pouze kladné frekvence a pro komplexní signály kladné i záporné frekvence. Viz Lst.~\ref{lst:fouriers} pro příklad použití a Lst.~\ref{lst:fft-square-wave} pro verzi programu v Lst.~\ref{lst:fourier-square-pulse}, ale s použitím FFT místo ručního výpočtu koeficientů.

\lstinputlisting[caption=Výpočet Fourierovy transformace a výkonové spektrální hustoty., label=lst:fouriers]{../example_code/fouriers.py}
\begin{center}
    \includegraphics[width=0.5\linewidth]{fouriers.pdf}
\end{center}

\lstinputlisting[label=lst:fft-square-wave, caption=Fourierův koeficient obdélníkové vlny\, vypočtený pomocí FFT]{../example_code/fourier_series_square_wave_fft.py}

Jedna obzvláště důležitá Fourierova transformace je transformace exponenciálně tlumené oscilace, tj.
\begin{equation}
    s(t) = e^{-t/\tau}\sin(2\pi f t),
\end{equation}
což dává komplexní lorentzián, který je odezvou lineárního harmonického oscilátoru, viz sekce~\ref{sec:lho}. Tlumená oscilace je samozřejmě pohyb tlumeného lineárního harmonického oscilátoru. Příklad:
\lstinputlisting{../example_code/decaying_exponential.py}
\begin{center}
    \includegraphics{decaying_exponential.pdf}
\end{center}

\begin{syntax}[Ukládání dat a metadat do binárních souborů numpy.]
    \label{syn:npy}
    Doposud jsme při načítání dat z disku narazili pouze na jednoduché, čitelné textové soubory. To je ale velmi omezující způsob ukládání dat: data musí mít formu obdélníkové tabulky, soubory zabírají více místa, než je nutné (např. text \ls{1.234567890} vyžaduje 11 bajtů paměti, ale \ls{float} reprezentující stejné číslo potřebuje pouze 8), a je nepohodlné ukládat metadata.

    Mnoho formátů souborů tyto problémy řeší (např. HDF5 je populární). Zde použijeme řešení, které nevyžaduje žádné další externí knihovny -- ukládání slovníků do komprimovaných binárních souborů \ls{.npy}, např. uložení
\begin{lstlisting}
    raw_data = np.linspace(0, 1, 50)
    my_data = {
        'date of measurement': '20241224',
        'was Mercury in retrograde': False,
        'data': raw_data
    }
    np.save("my_data.npy", my_data)
\end{lstlisting}
    a načtení
\begin{lstlisting}
    my_data = np.load("my_data.npy", allow_pickle=True).item()
    print(my_data['date of measurement'])
    print(my_data['data'])
\end{lstlisting}

    \textbf{Pickling} je pythonovský termín pro ukládání téměř jakéhokoli objektu Pythonu na disk jako binární data. Načítání ,,picklovaného'' objektu může být za určitých okolností bezpečnostním rizikem (tj. vyhněte se čtení ,,picklovaných'' dat, která jste stáhli z podivných míst na internetu), proto to musíme explicitně povolit. Funkce \ls{np.load} a \ls{np.save} pracují s poli, proto \ls{np.load()} vrací pole délky 1, kde náš slovník je jediným prvkem. Metoda \ls{array.item()} vrací \ls{array[0]}, pokud má \ls{array} délku 1, jinak vyvolá výjimku \ls{ValueError}. Jejím účelem je sémanticky naznačit, že očekáváme, že pole bude mít pouze jeden prvek, a pokud ne, něco je špatně.
    
    \begin{exercise}
    Načtěte data z adresáře \ls{timeseries_data} a vykreslete časovou závislost přibližné střední teploty během měření. Načtěte soubory pomocí \ls{d = np.load(filename, allow_pickle=True).item()}. Teplota na začátku a na konci měření je \ls{d['Ti']} a \ls{d['Tf']}.
    
    \emph{Nápověda:} Pro získání časového znaku (\emph{timestamp}, počet sekund od 00:00 1.1.1970) můžete použít \ls{time.mktime(time.strptime(fn, 'DM_\%Y\%m\%d-\%H\%M\%S.npy'))}, kde \ls{fn} je název souboru.
\end{exercise}
\end{syntax}

\begin{exercise}
    Vykreslete časovou řadu a spektrální hustotu pulzu použitého k buzení rezonance v binárních datových souborech \ls{data/timeseries_data} (viz Ukládání a načítání binárních souborů \ref{syn:npy}) pomocí \ls{scipy.signal.periodogram} a pomocí funkcí (r)FFT z \ls{scipy.fft}. Pulz lze načíst jako \ls{d['pulse']}, počet bodů lze získat jako \ls{d['samples']} (stejné jako \ls{len(d['pulse'])}) a vzorkovací frekvenci jako \ls{d['rate']}. Vykreslete pouze jeden soubor (pulz je pro všechny stejný).
\end{exercise}

\begin{exercise}
    Vykreslete časovou řadu (jako funkci skutečného času) odezvy rezonátoru (\ls{d['timeseries']}) a frekvenční závislost její Fourierove transformace (reálnou i imaginární složku) pro soubor odpovídající nejnižší teplotě v adresáři \ls{timeseries_data}. Vypočítejte frekvenční odezvu jako poměr Fourierových transformací odezvy rezonátoru a budícího pulzu. Vykreslete pouze frekvence $|f| < 3000$, hledaná rezonance je v rozsahu přibližně 2000 - 2400 Hz.
\end{exercise}

\begin{exercise}
    \label{ex:response-heat-map}
    Vykreslete velikost (tj. absolutní hodnotu) odezvy rezonátoru $r$ jako 2D teplotní mapu v závislosti na frekvenci a teplotě (tj. každá řádka v 2D grafu by měla být jedno spektrum odpovídající jedné teplotě).
\end{exercise}

\begin{exercise}
    Jako cvičení~\ref{ex:response-heat-map}, ale zprůměrujte všechna spektra, jejichž teplota je bližší než 50 mK (tato technika vyhlazování se nazývá klouzavý průměr nebo sousední průměrování).
\end{exercise}

\paragraph{Amplituda, výkon, a decibel}

Při zpracování signálu často mluvíme o útlumu nebo zisku (nebo zesílení, \emph{gain}) systému, např. kabeláže, zesilovačů nebo atenuátorů. Zisk je definován jako poměr výstupního a vstupního signálu a často se měří v decibelech, definovaných jako
\begin{equation}
    g = 10\log_{10}\frac{s_\mathrm{out}}{s_\mathrm{in}} \mathrm{[dB]}
\end{equation}
nebo pro výkon, tj. $s = V^2$,
\begin{equation}
    g = 20\log_{10}\frac{V_\mathrm{out}}{V_\mathrm{in}}
\end{equation}

Pro ,,absolutní'' veličiny měřené v dB (např. amplituda zvuku je běžná) je měření definováno vzhledem k nějaké dohodnuté referenční hodnotě. Pro zvuk se akustický výkon (tj. druhá mocnina tlaku) měří relativně k 20 \textmu Pa ve vzduchu. V elektronice, zejména v radiofrekvenčním (RF) inženýrství, je běžnou jednotkou dBm, kde 0 dBm odpovídá 1 mW výkonu, tj. pro zátěž 50 \textohm~asi 0.224 V$_\mathrm{RMS}$.

Pro amplitudy odpovídá zdvojnásobení signálu +3 dB a poloviční signál -3 dB a pro výkon je to +6 dB a -6 dB.

\subsection{Filtrování}

Filtrování je postup, kterým odstraňujeme určité frekvenční rozsahy ze vstupního signálu. Tyto postupy jsou obecné, ale nejjednodušší příklady jsou založeny na analogii s jednoduchými elektronickými RC filtry, viz Obr.~\ref{fig:RC-lowpass}. V závislosti na uspořádání rezistoru a kondenzátoru vytvoříme obvod, který buď zeslabuje nízké, nebo vysoké frekvence.
\begin{figure}
    \centering
    \includegraphics[width=0.49\linewidth]{low-pass-RC.png}%
    \includegraphics[width=0.49\linewidth]{high-pass-RC.png}%
    \label{fig:RC-lowpass}
    \caption{Dolní propust (vlevo) a horní propust (vpravo) RC filtr.}
\end{figure}

Použitím impedance kondenzátoru $Z_C = (i\omega C)^{-1}$ pro napětí oscilující na úhlové frekvenci $\omega$ dostaneme pro dolní propust
\begin{equation}
    \frac{V_\mathrm{out}}{V_\mathrm{in}} = \frac{1}{1 + i\omega RC},
\end{equation}
a pro horní propust
\begin{equation}
    \frac{V_\mathrm{out}}{V_\mathrm{in}} = \frac{i\omega RC}{1 + i\omega RC}.
\end{equation}
Výše uvedené výrazy se nazývají přenosové funkce filtru. Veličina $RC = \tau$ se nazývá časová konstanta. Mezní frekvence $f_c = 1/(2\pi\tau)$ je frekvence, při které filtr začíná působit. Odezvu filtrů můžeme vykreslit následujícím kódem
\lstinputlisting[firstline=4,lastline=12]{../example_code/RC_filters_response.py}
\begin{center}
    \includegraphics{RC_filters.pdf}
\end{center}
Obrázek ukazuje absolutní hodnotu přenosové funkce pro dolní a horní propust RC filtrů. Svislá čára je mezní frekvence.

Všimněte si, že přenosové funkce jsou funkcemi frekvence a obvody, které reprezentují, jsou lineární, tj. působí na každou frekvenci nezávisle. Proto, pokud je $s(t)$ náš signál a $\hat s(f)$ jeho Fourierova transformace, Fourierova transformace signálu filtrovaného přenosovou funkcí $H(f)$ je jednoduše
\begin{equation}
    \hat s'(f) = H(f)\hat s(f),
\end{equation}
tj. filtry ve frekvenční doméně jednoduše násobí spektrum. V časové doméně $s'(t) = \mathcal{F}^{-1}[H\hat s]$; Fourierova transformace násobení je konvoluce, tj.
\begin{equation}
    s'(t) = (h*s)(t) \equiv \int_{-\infty}^t s(t')h(t - t')\dd t,
\end{equation}
kde $h$ je inverzní Fourierova transformace $H$ a nazývá se konvoluční jádro. FFT je často nejrychlejší způsob výpočtu konvoluce. Nemusíme ji implementovat sami, protože existuje \ls{scipy.signal.convolve(a, b)}, která počítá konvoluci signálů \ls{a} a \ls{b}.

Pro dolní propust RC filtru lze dokázat, že
\begin{equation}
    h(t) = \left\{\begin{matrix}
        e^{-t/\tau} & \mathrm{for}\; t > 0 \\
        0 & \mathrm{for}\; t < 0
    \end{matrix}\right.
\end{equation}
což lze také snadno implementovat pro data která přichází v reálném čase (streaming data), pro která se často nazývá \emph{exponenciální vyhlazování}.

Kromě dolní a horní propusti existují také pásmové propusti a pásmové zádrže (\emph{band pass} a \emph{band stop}). Pásmová propust propouští pouze určité frekvenční pásmo (tj. interval) a pásmová zádrž propouští vše kromě určitého frekvenčního pásma. Pásmovou propust i zádrž si můžete představit jako horní propust následovanou dolní propustí v sérii s mezními frekvencemi danými propustným nebo zadržovaným pásmem.

Jednoduché RC filtry jsou tzv. prvního řádu. Řád filtru udává, jak rychle ořezává signál mimo \emph{propustné pásmo} (tj. interval frekvencí, které filtr propouští). To se často měří v decibelech na oktávu (dB/okt), což udává, o kolik decibelů je signál zeslaben, pokud se jeho frekvence zdvojnásobí, pro dolní propust, nebo zmenší na polovinu pro horní propust, dostatečně daleko od mezní frekvence. Oba RC filtry jsou 6 dB/okt, protože každé zdvojnásobení (nebo půlení) frekvence odstraní 6 dB přenášeného výkonu.

Rychlejší filtry lze konstruovat jak elektronicky, tak digitálně, ale jak jste viděli v příkladech s krokovou funkcí, ostrý přechod ve spektru vede k oscilacím, které jsou obvykle nežádoucí. Filtry, které jsou maximálně ploché v propustném pásmu jsou tzv. Butterworthovy filtry, pojmenované po Stephenu Butterworthovi, které mají amplitudový zisk
\begin{equation*}
    G_n(\omega) = \frac{1}{\sqrt{1 + \frac{\omega^{2n}}{\omega_c^{2n}}}},
\end{equation*}
kde $\omega_c$ je mezní (úhlová) frekvence. Tyto filtry můžeme zkonstruovat pomocí \ls{scipy.signal.iirfilter} a aplikovat je na náš signál pomocí \ls{scipy.signal.sosfilter}
\lstinputlisting[firstline=7, lastline=25]{../example_code/sig_iirfilter.py}:
\begin{center}
    \includegraphics[width=0.5\linewidth]{butter.pdf}
\end{center}

\begin{exercise}
    \label{ex:filter}
    Napište funkci, která bude filtrovat vstupní signál pomocí
    \begin{enumerate}
        \item dolně propustního RC filtru s nastavitelnou mezní frekvencí
        \item horně propustního RC filtru podobně jako v bodě 1.
        \item Butterworthova pásmové propusti zkonstruovaného pomocí \ls{scipy.signal.iirfilter()} a aplikovaného pomocí \ls{scipy.signal.lfilter()}
    \end{enumerate}

    Pro 1. a 2. vykreslete přenosovou funkci filtru. Otestujte filtrování na přiloženém \ls{noisy_data.npy} a vykreslete signál v časové i frekvenční doméně před a po filtrování. Pro dolní propust odfiltrujte vše nad 100 Hz. Pro horní propust vše pod 1000 Hz a pro pásmovou propust ponechte pouze rozsah (4310, 4330) Hz.
\end{exercise}

% \subsection{Homodyne and heterodyne detection, signal envelope}
% TODO: mixing, homodyne and heterodyne detection, lock-in amplification

\begin{exercise}
    \label{ex:envelope-direct}
    Demodulujte vyčištěný signál z Cvič.~\ref{ex:filter} (pomocí Butterworthovy pásmové propusti) na nosné frekvenci 4321 Hz (vynásobte $e^{i\omega t}$ a filtrujte dolní propustí) a vykreslete obálku modulující nosnou vlnu.
\end{exercise}

\begin{exercise}
    \label{ex:envelope-hilbert}
    Vypočítejte obálku signálu z Cvič.~\ref{ex:envelope-direct} pomocí Hilbertovy transformace.
\end{exercise}

\subsection{Interpolace a shlazování}

Čast bývá nutno odhadnout hodnotu závislosti $y(x)$ v libovolném $x$ když sou známi jenom diskrétní dvojice $(x_i, y_i)$. Tento proces se nazýva interpolace. Nejjednodušší je lineární interpolace, která jednoducho pospájí sousední $(x_i, y_i)$ a $(x_{i+1}, y_{i+1})$ rovnými čarami. Takáto interpolovaná fuknce je síce spojitá, no není hladká. Místo rovných čar mezi sousdními body můžeme ale použít polynomy tak, aby spojité neboli jenom interpolované hodnoty ale i derivace do určitého řádu, čím dostávame tzv. spliny [splajny].

Pro interpolaci máme modul \ls{scipy.interpolate} který obsahuje funkci \ls{interp1d} pro interpolaci lineární i pomocí kubických splajnů. Funkce příjmá data a vrací volatelný objekt, příklad (celý kód v \ls{interpolation.py}):
Importujeme balíky a definujeme data šumem
\lstinputlisting[linerange={1-6}]{../example_code/interpolation.py}
Vytvoríme lineární a kubickou interpolaci
\lstinputlisting[linerange={8-9}]{../example_code/interpolation.py}
A všecho nakreslíme spolu nezašumenou hodnotou pro porovnání
\lstinputlisting[linerange={11-18}]{../example_code/interpolation.py}
\begin{center}
    \includegraphics[width=0.75\linewidth]{interpolation.pdf}
\end{center}

Pomocí splajn je možno data i \emph{shlazovat}. To nám umožňuje parameter $s$ funkce \ls{make_splrep} který specifikje, jak daleko může být splajna od dat a $s=0$ značí interpolaci, příklad (parameter $k$ specifikuje řád polynomu)
\lstinputlisting[linerange={21-27}]{../example_code/interpolation.py}
\begin{center}
    \includegraphics[width=0.75\linewidth]{interpolation_s.pdf}
\end{center}

Shlazující splajny jsou jeden zo spůsobů jak derivovat zašumená experimentální data. Objekty vráceni \ls{make_splrep} mají metodu \ls{derivative()}, která, jak název napovedá, vrátí derivaci. Příklad
\lstinputlisting[linerange={30-34}]{../example_code/interpolation.py}
\begin{center}
    \includegraphics[width=0.75\linewidth]{interpolation_diff.pdf}
\end{center}

Pro shlazování kdy nepotřebujeme interpolaci je užitočná \ls{scipy.signal.savgol_filter}, která implementuje Savitzkyho-Golajův filtr. Jedná sa v podstate o zobecnění průměrování sousdních bodů, kde ale namísto "fitování" konstanty na pohyblivé okno fitujeme polynom. Příklad,
\lstinputlisting[linerange={37-42}]{../example_code/interpolation.py}
\begin{center}
    \includegraphics[width=0.75\linewidth]{savgol.pdf}
\end{center}

Pro shlazování ve více dimenzích (ale i v 1D) je užitočné \ls{scipy.ndimage.gaussian_filter} která konvoluje zadané data s gaussovským kernelem s šírkou která je dána parametrem \ls{sigma}, který může být buď skalár, nebo n-tice, příklad (celý kód v \ls{gaussian_filter.py})
Nejprve importujeme potrebné knihovny a vytovríme jednoduchá 2D data -- 100$\times$100 matice s 0 všude kroomě kolečka o průměru 0.5 ve středu os
\lstinputlisting[linerange={1-9}]{../example_code/gaussian_filter.py}
Původní i filtrovaná data nakreslíme. Všimněte si, že \ls{gaussian_filter()} nepoužívá hodnoty $x$ a $y$, předpokládá, že data jsou rovnoměrně rozložena.
\lstinputlisting[linerange={11-18}]{../example_code/gaussian_filter.py}
\begin{center}
    \includegraphics[width=0.75\linewidth]{gaussian_filter.pdf}
\end{center}